# Trees

:::tip common questions

- [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

:::

### [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

#### Solution 1: Recursive Approach

```py
# class TreeNode:
# def __init__(self, x):
#   self.val = x
#   self.left = None
#   self.right = None

def lowestCommonAncestor(self, root, p, q):
  if not root or root == p or root == q:
    return root

  left = self.lowestCommonAncestor(root.left, p, q)
  right = self.lowestCommonAncestor(root.right, p, q)

  if left and right:
    return root
  else:
    return left or right
```

Time Complexity: `O(n)` for traversing the entire binary tree.

Space Complexity: `O(n)` for the size of recursion stack.

<br />

#### Solution 2: Iterative Approach

```py
# class TreeNode:
# def __init__(self, x):
#   self.val = x
#   self.left = None
#   self.right = None

def lowestCommonAncestor(self, root, p, q):
  stack = [root]
  parent = {root: None}
  while p not in parent or q not in parent:
    node = stack.pop()
    if node.left:
      stack.append(node.left)
      parent[node.left] = node
    if node.right:
      stack.append(node.right)
      parent[node.right] = node

  ancestor = set()
  while p:
    ancestor.add(p)
    p = parent[p]
  while q not in ancestor:
    q = parent[q]
  return q
```

Time Complexity: `O(n)` for traversing the entire binary tree.

Space Complexity: `O(n)` for the spaced used for stack and parent dictionary.

<br />
